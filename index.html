<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/07/JVM内存模型概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/07/JVM内存模型概述/" itemprop="url">
                  JVM内存模型概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-07 17:34:04 / 修改时间：17:35:20" itemprop="dateCreated datePublished" datetime="2018-11-07T17:34:04+08:00">2018-11-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存模型是什么"><a href="#JVM内存模型是什么" class="headerlink" title="JVM内存模型是什么"></a>JVM内存模型是什么</h1><p>(本文基于JDK1.8)  </p>
<p>JVM内存模型也叫做JVM运行时数据区。<br>JVM本身也是操作系统中的一个进程，操作系统自然会给它分配一定的内存空间，JVM在设计时对这个属于它自己的内存空间人为的划分为多个数据区域，使得JVM可以更好的运行Java程序。</p>
<h1 id="JVM内存模型的组成部分"><a href="#JVM内存模型的组成部分" class="headerlink" title="JVM内存模型的组成部分"></a>JVM内存模型的组成部分</h1><p>JVM内存模型根据是否线程共享可分为两大区域。</p>
<h2 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li>作用：存放对象实例，几乎所有的对象实例(包括数组)都在这里分配内存。比如我们用new关键字创建出来的对象，就会放到堆内存中。 </li>
<li>特点：堆也叫做GC堆，因为堆内存中放的都是对象实例，自然就是GC垃圾收集器重点关注的地方。堆内存可以再细分为新生代、老年代。新生代又可以按8:1:1的比例再细分为Eden、survivor0、survivor1区域。<blockquote>
<p> 为什么堆内存又得继续细分呢？<br>因为现在的垃圾收集器用的都是分代收集算法，所以对堆内存继续细分，对不同的堆内存就可以用更合适的垃圾收集算法，就能提高GC的效率。<br>刚创建的对象或比较年轻的对象都会存放到新生代中，如果对象一直没有被回收，会被放到老年代。<br>具体来说，刚创建的对象是放到了新生代的Eden区。如果对象至少经历过一次GC并且幸存，会被放到survivor0,survivor1区。</p>
</blockquote>
</li>
<li>注意：堆内存逻辑上连续，物理上不一定连续。我们可以通过参数-Xmx来设置最大堆内存，-Xms设置最小堆内存。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>作用：方法区中保存的是类的基本信息、类变量、字段、方法、运行时常量池、指向类加载器的引用、指向Class对象实例的引用等。简单理解，方法区保存的是类的基本结构。</li>
<li>注意：方法区本身是JVM设计规范里的概念，在JVM中并不实际存在一个叫做方法区的内存区域。在JDK1.7的时候，方法区是由永久代实现的，在JDK1.8的JVM内存模型中，取消了永久代，用元空间(meta space)代替永久代来实现方法区。<blockquote>
<p>永久代和元空间本身也只是一块内存区域，它们的区别在于，永久代属于JVM的一部分，而元空间独立于JVM，直接属于本机内存的一部分。</p>
</blockquote>
</li>
</ol>
<h2 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h2><p>线程私有，是说每个线程都会有下面的三个内存区域：虚拟机栈、本地方法栈、程序计数器(PC)。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ol>
<li>作用：虚拟机栈本质就是栈，它可以理解为Java的方法内存模型。线程在调用Java方法的时候，就会为这个方法创建一个栈帧(保存方法里的一些必要信息)， 然后栈帧入栈。方法执行完毕后，对应的栈帧就会出栈。<blockquote>
<p>每个栈帧包括：局部变量表、操作数栈、动态链接、方法出口等信息</p>
</blockquote>
</li>
<li>注意：方法无论正常执行完毕还是执行时抛出了未被捕获的异常，方法对应的栈帧都会出栈。 我们可以通过参数-Xss来设置虚拟机栈的大小。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ol>
<li>作用：本地方法栈本质也是栈，和虚拟机栈的作用类似。不过它是为JVM调用Java中的native方法提供服务。<blockquote>
<p>native方法就是用其他语言(C/C++)写的方法，集成在Java的类里面，JVM中可以调用非java方法。例如java.lang.Object类中的hashCode()方法，就是native方法。</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
<h3 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h3><ol>
<li>作用：记录当前线程正在执行的字节码的行号。如果当前线程执行的是native方法，则PC的值就是undefined<blockquote>
<p>为什么每个线程都要有程序计数器？<br>因为Java支持多线程编程，在一个CPU内核中某一个时刻只能执行一个线程中的一条指令，线程间的切换执行就需要在PC中保存当前线程执行到第几行指令了，方便之后切换回来的时候能够恢复到之前执行的位置，然后继续往下执行。</p>
</blockquote>
</li>
</ol>
<h1 id="内存异常分析-SOF与OOM"><a href="#内存异常分析-SOF与OOM" class="headerlink" title="内存异常分析(SOF与OOM)"></a>内存异常分析(SOF与OOM)</h1><h2 id="堆中的OOM"><a href="#堆中的OOM" class="headerlink" title="堆中的OOM"></a>堆中的OOM</h2><p>JVM分配给堆的内存是有限的，虽然有垃圾回收机制来回收无用对象释放内存，但毕竟执行的时机不确定，没法立马全部回收。<br>如果我们不断创建对象，在某一时刻还是有可能会导致堆中的空间全部被消耗殆尽，没法再创建新的对象，JVM会抛出OutOfMemoryError，即OOM。</p>
<p>怎么解决呢？  </p>
<p>可以用一些工具去分析内存，先确定是内存泄漏还是内存溢出。</p>
<blockquote>
<p>内存泄漏：对象使用了某块内存，但这个对象无法被回收，导致它对应的内存无法被释放。久而久之就有可能导致内存溢出。<br>内存溢出：程序申请内存时，发现已经没有足够的内存可以分配给对象了。</p>
</blockquote>
<p>如果是内存泄漏，那就用工具去找找这个对象是谁，看它有没有存在的必要。  </p>
<p>如果是内存溢出，那就去设置虚拟机中最大堆内存(参数-Xmx)。</p>
<h2 id="虚拟机栈中的SOF与OOM"><a href="#虚拟机栈中的SOF与OOM" class="headerlink" title="虚拟机栈中的SOF与OOM"></a>虚拟机栈中的SOF与OOM</h2><ol>
<li>SOF<br>虚拟机栈中，存放的是每个方法对应的栈帧。如果一个线程里，嵌套调用了非常多方法，那么在方法没执行完返回的时候，虚拟机栈中就会有很多很多栈帧。<br>如果分配给虚拟机栈的内存被这些栈帧用完了，此时再去压入新的栈帧，JVM就会抛出StackOverFlowError(SOF)。<br>一般来说，递归的时候容易出现SOF。<br>如何解决呢？<br>设置虚拟机栈的容量(参数-Xss)</li>
<li>OOM<br>在Java中创建一个新线程，JVM就会给这个线程分配一部分内存空间来放虚拟机栈，当不够内存来分配虚拟机栈时，JVM就会抛出StackOverFlowError(SOF)。</li>
</ol>
<h2 id="PC不会有OOM问题"><a href="#PC不会有OOM问题" class="headerlink" title="PC不会有OOM问题"></a>PC不会有OOM问题</h2><p>PC程序计数器不会有任何OutOfMemoryError问题。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/浅谈Java类加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/浅谈Java类加载/" itemprop="url">
                  浅谈Java类加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-05 15:16:43 / 修改时间：15:23:07" itemprop="dateCreated datePublished" datetime="2018-11-05T15:16:43+08:00">2018-11-05</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h2><p>我们写的每个类即.java文件，都会被编译器编译为.class字节码文件。   </p>
<p>当Java程序需要使用某个类的时候，就去加载它的.class字节码文件到JVM，在JVM的方法区保存类的基本结构，在堆中创建对应的java.lang.Class对象。</p>
<h2 id="类加载的过程-1"><a href="#类加载的过程-1" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>加载–&gt;链接–&gt;初始化  </p>
<p>(链接还可以进行细分：验证–&gt;准备–&gt;解析)  </p>
<p>所以，总体来看类的加载过程可以分为五个步骤：<br>加载–&gt;验证–&gt;准备–&gt;解析–&gt;初始化</p>
<ol>
<li>加载：根据类的全名去找到对应的二进制字节流，可以从本地、网络等地方获取。  把字节流代表的静态存储结构转化为方法区的运行时数据结构。<br>创建表示该类型的java.lang.Class类型的对象，通过它可以访问类在方法区的基本结构(比如方法、字段等，这也是反射的基础)。</li>
<li>验证：检查字节码文件的格式，语义等，确保字节码文件加载后不会危害JVM运行。</li>
<li>准备：在方法区中为静态变量分配内存空间，并进行默认初始化(例如int类型就默认初始化为0，boolean类型就默认初始化为false)。</li>
<li>解析：把字节码文件中的符号引用转换为直接引用。比如这个符号代表方法、字段等，那就把这个符号转为了它们在内存中的指针或偏移量，方便直接访问)</li>
<li>初始化：把类中所有被static关键字修饰的代码都执行一遍。即把用户指定的值赋值给静态变量，执行静态代码块的代码。<br>所有被static关键字修饰的代码在编译的时候会被放到一个叫做&lt;clinit&gt;的方法中，在类加载到[初始化]这个阶段的时候，由JVM调用这个&lt;clinit&gt;方法。<br>如果加载的这个类有父类，那么JVM会确保先调用父类的&lt;clinit&gt;方法，再调用子类的&lt;clinit&gt;方法。<br>如果多线程同时初始化一个类，JVM会确保只有一个线程可以执行类的&lt;clinit&gt;方法，而且只能执行一次。<blockquote>
<p>这个特性，也是饿汉式单例模式为什么不用synchronized也能保证线程安全的原因，因为唯一实例用static修饰，这些代码会放&lt;clinit&gt;方法中并由JVM调用。即便在多线程环境下，也只执行一次创建实例的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton instance = new Singleton();</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h1 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h1><ul>
<li>Boostrap ClassLoader  顶层的启动类加载器： 加载JAVA_HOME/lib 加载这里的核心类库(比如rt.jar) 。它不是Java类，是用C++写的， 嵌在JVM内核里面，JVM启动的时候它就存在了</li>
<li>Extension ClassLoader 扩展类加载器：  加载JAVA_HOME/lib/ext下的类库</li>
<li>Application ClassLoader 应用程序类加载器：  加载classpath下的类库</li>
<li>继承java.lang.ClassLoader的自定义类加载器  </li>
</ul>
<blockquote>
<p>除了顶层的Boostrap启动类加载器，其他的类加载器都有自己的父类加载器，但它们不是通常所说的继承关系。<br>Boostap启动类加载器用C++实现，是虚拟机自身的一部分。其他的类加载器由Java实现，独立于虚拟机，这些类加载器都继承自抽象类java.lang.ClassLoader</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ClassLoader</span><br></pre></td></tr></table></figure>
<p>代码验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ClassLoaderDemo classLoader = new ClassLoaderDemo();</span><br><span class="line">		Class clazz = classLoader.getClass();</span><br><span class="line">		System.out.println(&quot;加载当前类的Application类加载器:&quot; + clazz.getClassLoader());</span><br><span class="line">		System.out.println(&quot;Application类加载器的父类加载器:&quot; + clazz.getClassLoader().getParent());</span><br><span class="line">		System.out.println(&quot;Extension类加载器的父类加载器:&quot; + clazz.getClassLoader().getParent().getParent());</span><br><span class="line">		//因为Bootstrap类加载器是C++写的，不是java类，所以这里是获取不到Bootstrap类加载器的，返回的是null</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">加载当前类的Application类加载器:sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">Application类加载器的父类加载器:sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">Extension类加载器的父类加载器:null</span><br></pre></td></tr></table></figure>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="双亲委派机制的工作原理"><a href="#双亲委派机制的工作原理" class="headerlink" title="双亲委派机制的工作原理"></a>双亲委派机制的工作原理</h2><p>简单来说，双亲委派机制的工作原理就是：<strong>父类优先加载</strong>  </p>
<p>如果一个类加载器收到类加载请求，它不会立即加载，而是把加载请求传给父类加载器，父类加载器再传给它的父类加载器，一层一层传递，最后所有的加载请求都会先到达最顶层的Bootstrap启动类加载器。<br>如果父类加载器能加载，那就加载。如果它加载不了，就会一层一层往下通知，让子类加载器去加载。</p>
<blockquote>
<p>比如我们自己写一个带main方法的类，然后编译,运行这个类。它会被加载进JVM。<br>首先Application类加载器会收到加载请求，它把请求传给父类Extension类加载器，Extension类加载器则把请求再交给最顶层的Bootstrap类加载器。<br>Bootstrap类加载器尝试加载，去JAVA_HOME/lib目录下查找这个类的字节码文件，找不到。则通知子类Extension类加载器去加载。<br>Extension类加载器去JAVA_HOME/lib/ext目录下查找这个类的字节码文件，也找不到，则通知Application类加载器去加载。<br>Application类加载器去classpath下查找这个类的字节码文件，找到了，然后加载到JVM中。</p>
</blockquote>
<h2 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h2><ol>
<li>避免类的重复加载：<br>因为在加载之前都会先判断父类加载器有没有加载过，加载过那就不加载了。</li>
<li>确保核心类库的安全：<br>如果有人自己写了一个全名是java.lang.Object的类，通过双亲委派机制加载时，会先让顶层Bootstrap类加载器先加载，它去查对应的加载路径JAVA_HOME/lib，发现核心类库有java.lang.Object这个类，那就加载这个类，而不是加载用户自定义的同名核心类，确保了Java核心类库的安全，不会影响Java程序的运行。</li>
</ol>
<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><h2 id="类什么时候初始化"><a href="#类什么时候初始化" class="headerlink" title="类什么时候初始化"></a>类什么时候初始化</h2><p>虚拟机规范规定，有且只有5种情况必须立即对类进行初始化(此时已经完成了加载、验证、准备、解析阶段)：</p>
<ol>
<li>使用new关键字创建对象、访问一个类的静态字段或静态方法(被final修饰的静态字段除外)</li>
<li>使用java.lang.reflect包的方法对类进行反射，若类没进行初始化，要先初始化</li>
<li>初始化一个类时，如果它的父类还没初始化，那么要先初始化父类</li>
<li>虚拟机启动的时候，先初始化带main()方法的主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic等时， 这个方法的类还没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<blockquote>
<p>注意：<br>类的实例化和类的初始化不是一回事，是两个完全不同的概念！<br>类的实例化，是指在堆中分配内存，创建类的对象。<br>类的初始化，是指类加载时的一个阶段，负责给类的静态变量赋值，执行静态代码块。</p>
</blockquote>
<h2 id="JVM如何判断两个Class对象是否相同"><a href="#JVM如何判断两个Class对象是否相同" class="headerlink" title="JVM如何判断两个Class对象是否相同"></a>JVM如何判断两个Class对象是否相同</h2><ol>
<li>类的完整类名必须一致(包名.类名)</li>
<li>加载这个类的ClassLoader对象也必须一致<blockquote>
<p>也就是说，即便这两个Class对象来源于同一个class字节码文件，但是由于加载它们的ClassLoader对象不同，JVM会认为这是两个不同的Class对象。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/HashMap源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/HashMap源码分析/" itemprop="url">
                  HashMap源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-04 19:33:17 / 修改时间：19:34:06" itemprop="dateCreated datePublished" datetime="2018-11-04T19:33:17+08:00">2018-11-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap是什么"><a href="#HashMap是什么" class="headerlink" title="HashMap是什么"></a>HashMap是什么</h1><p>(注：本文基于JDK1.8)</p>
<p>HashMap是一个基于哈希表实现的容器，用来存储键值对。既然基于哈希表，那必须要考虑哈希函数和解决哈希冲突的方法。  </p>
<p> HashMap的哈希函数是除留余数法，在代码中体现的话，就是算出Key的Hash值，用这个Hash值对数组长度进行一个取模运算，就能算出键值对存放在数组的哪个位置上。  </p>
<p>HashMap解决哈希冲突的方法是链地址法，如果发生哈希冲突，就把冲突的键值对插入到数组对应位置的链表上。</p>
<h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><p>JDK1.7中，HashMap底层的实现是数组+单向链表  </p>
<p>JDK1.8中，HashMap底层的实现是数组+单向链表+红黑树。</p>
<blockquote>
<p>   在JDK1.7中， 如果出现频繁的哈希冲突，会导致链表太长，那么对HashMap中键值对操作的效率就会下降。为了解决这个问题，JDK1.8在原先结构的基础上，引入红黑树。<br>如果数组中某个位置上的链表长度大于8，则链表自动转换为红黑树，如果红黑树节点个数小于6时则会自动转换为链表。</p>
</blockquote>
<h1 id="HashMap相关操作的源码分析"><a href="#HashMap相关操作的源码分析" class="headerlink" title="HashMap相关操作的源码分析"></a>HashMap相关操作的源码分析</h1><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><h3 id="Node和数组"><a href="#Node和数组" class="headerlink" title="Node和数组"></a>Node和数组</h3><p>可以发现，HashMap底层是一个Node数组。<br>Node是HashMap中的一个静态内部类，传入HashMap的Key-Value会被封装成Node结点，存入数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;    //用来定位数组索引位置</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;    //链表的下一个node</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey() &#123; return key; &#125;</span><br><span class="line">    public final V getValue() &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o == this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;  Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>JDK1.8中的HashMap引入了红黑树这一结构。<br>TreeNode就是红黑树，也是HashMap的静态内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前节点的根节点</span><br><span class="line">    final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... 后面的省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组默认长度和最大长度"><a href="#数组默认长度和最大长度" class="headerlink" title="数组默认长度和最大长度"></a>数组默认长度和最大长度</h3><ul>
<li>数组默认长度为16，必须为2的次幂</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br></pre></td></tr></table></figure>
<ul>
<li>最大容量是2的30次方<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="负载因子和阈值"><a href="#负载因子和阈值" class="headerlink" title="负载因子和阈值"></a>负载因子和阈值</h3><ul>
<li>负载因子表示HashMap内部空间的使用情况。默认负载因子是0.75。当HashMap中存储的键值对个数 &gt;= 容量 * 负载因子 时，HashMap就会进行扩容。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表和红黑树转换的阈值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> //链表长度大于8时，将链表转化为红黑树</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;  </span><br><span class="line"></span><br><span class="line">//如果发现链表长度小于 6，则会将红黑树重新退化为链表</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="键值对存放在数组哪个位置的计算过程"><a href="#键值对存放在数组哪个位置的计算过程" class="headerlink" title="键值对存放在数组哪个位置的计算过程"></a>键值对存放在数组哪个位置的计算过程</h4><ol>
<li><p>先根据Key得到hash值(调用继承自Object类的hashCode()方法)</p>
<blockquote>
<p>Object类的hashCode()方法是一个native方法，返回的是和对象内存地址相关的一个值，类型是int</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>对这个hash值做一下处理 (h=key.hashCode()) ^ (h&gt;&gt;&gt;16)</p>
</li>
</ol>
<blockquote>
<p>hash值的高16位和低16位做异或运算后，保证hash值的高位和低位都参与到后面的数组下标计算中，降低哈希碰撞的概率。  </p>
</blockquote>
<ol start="3">
<li>用位运算代替取模运算 得出键值对存放的数组下标</li>
</ol>
<blockquote>
<p>在数组长度是2^n的情况下，h &amp; (length - 1) 就相当于 h % length,CPU处理位运算的效率高于%取模运算。这也是为什么HashMap底层数组的长度为什么一定要是2^n的原因。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		int h = 33673434;</span><br><span class="line">		int length = 16; //数组长度是2的次幂</span><br><span class="line">		System.out.println(&quot;h % length :&quot; + (h % length));</span><br><span class="line">		System.out.println(&quot;h &amp; (length - 1) :&quot; + (h &amp; (length - 1)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	运行结果：</span><br><span class="line">	h % length :10</span><br><span class="line">    h &amp; (length - 1) :10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int h = 33673434;</span><br><span class="line">	int length = 15; //数组长度不是2的次幂</span><br><span class="line">	System.out.println(&quot;h % length :&quot; + (h % length));</span><br><span class="line">	System.out.println(&quot;h &amp; (length - 1) :&quot; + (h &amp; (length - 1)));</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">h % length :9</span><br><span class="line">   h &amp; (length - 1) :10</span><br></pre></td></tr></table></figure>
<h3 id="put方法的流程"><a href="#put方法的流程" class="headerlink" title="put方法的流程"></a>put方法的流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // tab为空则创建</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 计算index，并对null做处理</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 判断该链为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 该链为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    // 在Node添加到尾部</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 若链表长度大于8，则转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // key已经存在，直接覆盖value</span><br><span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //写入</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 如果大于threshold， 扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    //当tab.length&lt;MIN_TREEIFY_CAPACITY 时还是进行resize</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    // key存在，转化为红黑树</span><br><span class="line">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 建立树的根节点，然后对每个元素进行添加</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            if (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; while ((e = e.next) != null);</span><br><span class="line">        if ((tab[index] = hd) != null)</span><br><span class="line">            // 存储红黑树</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put()方法的大体流程：</p>
<ol>
<li>hash()方法得到一个处理过的hash值，对它进行位运算，得到键值对在数组中的存放位置。</li>
<li>如果这个位置上没有元素，那就把键值对封装为Node对象，放入该位置</li>
<li>如果这个位置上有元素，说明出现哈希冲突，如果当前位置元素是红黑树类型，就按红黑树的方式添加结点。如果当前位置元素是链表类型，就把元素插入到链表尾部。如果此时链表长度大于8，链表转化为红黑树。</li>
</ol>
<blockquote>
<p>注：如果put两个key相同，value不同的键值对到HashMap，后者会覆盖前者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap h = new HashMap&lt;&gt;();</span><br><span class="line">h.put(&quot;gdei&quot;, &quot;software&quot;);</span><br><span class="line">h.put(&quot;gdei&quot;, &quot;dzc&quot;);</span><br><span class="line">System.out.println(h.get(&quot;gdei&quot;));</span><br><span class="line"></span><br><span class="line">   运行结果：</span><br><span class="line">   dzc</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>JDK1.7中，键值对被封装成Node对象插入到链表头部。  </p>
<p>JDK1.8中，键值对被封装成Node对象插入到链表尾部。  </p>
</blockquote>
<h3 id="remove方法的流程"><a href="#remove方法的流程" class="headerlink" title="remove方法的流程"></a>remove方法的流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">        // 直接命中</span><br><span class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            // 红黑树中查找</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                // 链表中查找</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)</span><br><span class="line">                tab[index] = node.next;  </span><br><span class="line">            else</span><br><span class="line">                p.next = node.next;  </span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove方法的流程：</p>
<ol>
<li>hash()方法得到一个处理过的hash值，对它进行位运算，得到键值对在数组中的存放位置。</li>
<li>看元素是不是在当前位置。如果当前位置存放的是一个红黑树，那就从红黑树里找。如果当前位置存放的是链表，那就遍历链表去找。</li>
<li>找到后就删除。</li>
</ol>
<h3 id="get方法的流程"><a href="#get方法的流程" class="headerlink" title="get方法的流程"></a>get方法的流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 直接命中</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        // 未命中</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 在树中查找</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            // 在链表中查找</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法的流程：</p>
<ol>
<li>hash()方法得到一个处理过的hash值，对它进行位运算，得到键值对在数组中的存放位置。</li>
<li>看元素是不是在当前位置，是的话直接返回。</li>
<li>看当前位置存的是不是红黑树，是的话按红黑树的方式找，找到并返回。</li>
<li>看当前位置存的是不是链表，是的话就遍历链表去找，找到并返回。</li>
<li>找不到就返回null</li>
</ol>
<h3 id="resize方法的流程"><a href="#resize方法的流程" class="headerlink" title="resize方法的流程"></a>resize方法的流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;  // 获取原HashMap数组的长度。</span><br><span class="line">    int oldThr = threshold;  </span><br><span class="line">    int newCap, newThr = 0;  </span><br><span class="line">    if (oldCap &gt; 0) &#123; </span><br><span class="line">        // 超过最大值就不再扩充了</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;   </span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    // 遍历数组，然后对数组中的每个元素进行重新hash</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;  </span><br><span class="line">          </span><br><span class="line">               if (e.next == null) </span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;  </span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                      </span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; </span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123; </span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                  </span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reize()扩容的流程：</p>
<ol>
<li>获取HashMap原数组的长度</li>
<li>判断这个值是否超过数组最大长度(2^30)，超过就不扩容了。没超过扩容为原来的2倍(因为要保持数组长度是2的次幂)</li>
<li>HashMap存放的所有元素要进行重新hash，计算它们在新数组中的存储位置。<br>(如果HashMap存放的元素个数很多，那么扩容操作实际上是比较消耗性能的)</li>
</ol>
<h1 id="HashMap保存Key-Value时，对Key有什么要求"><a href="#HashMap保存Key-Value时，对Key有什么要求" class="headerlink" title="HashMap保存Key-Value时，对Key有什么要求"></a>HashMap保存Key-Value时，对Key有什么要求</h1><ul>
<li>理论上Key可以是任意类型，但一般是String或Integer这种不可变类。<br>因为HashMap是根据Key来计算键值对在数组中的存储位置的，如果它们可变，那么HashMap放进去的键值对，在Key变化后就可能取不出来了，因为找不到它们之前在数组中的存储位置了。</li>
<li>如果希望自定义类的对象来做Key，那么这个类必须要重写equals()和hashCode()方法。</li>
</ul>
<h1 id="为什么HashMap中对Key-Value的操作时间复杂度是O-1"><a href="#为什么HashMap中对Key-Value的操作时间复杂度是O-1" class="headerlink" title="为什么HashMap中对Key-Value的操作时间复杂度是O(1)"></a>为什么HashMap中对Key-Value的操作时间复杂度是O(1)</h1><p>准确来说，HashMap增删改查键值对的时间复杂度为O(1)是一种理想情况。  </p>
<p>比如put()插入一个键值对，先计算出它的存储位置。如果这个位置上是null的时候，插入的时间复杂度才是O(1)。如果这个位置上有链表或红黑树，那么插入的时间复杂度就分别是O(n)和O(logn)了。  </p>
<p>get()根据key获取value，也要先计算出它的存储位置，如果键值对刚好在这个位置上，那时间复杂度才是O(1)，否则要从链表或红黑树去找。  </p>
<p>所以，HashMap中的哈希冲突越少，链表越少，对键值对增删改查的性能就越好。</p>
<h1 id="HashMap线程安全吗，如果保存Key-Value时要求线程安全怎么办"><a href="#HashMap线程安全吗，如果保存Key-Value时要求线程安全怎么办" class="headerlink" title="HashMap线程安全吗，如果保存Key-Value时要求线程安全怎么办"></a>HashMap线程安全吗，如果保存Key-Value时要求线程安全怎么办</h1><p>HashMap是线程不安全类。如果保存键值对的时候要求线程安全，可以：</p>
<ol>
<li>用Collections.synchronizedMap()方法，传入HashMap</li>
<li>用ConcurrentHashMap代替HashMap</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/DNS劫持和HTTP劫持/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/DNS劫持和HTTP劫持/" itemprop="url">
                  DNS劫持和HTTP劫持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-03 21:23:53 / 修改时间：21:30:41" itemprop="dateCreated datePublished" datetime="2018-11-03T21:23:53+08:00">2018-11-03</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DNS劫持和HTTP劫持的现象"><a href="#DNS劫持和HTTP劫持的现象" class="headerlink" title="DNS劫持和HTTP劫持的现象"></a>DNS劫持和HTTP劫持的现象</h1><p>DNS劫持的现象：<br>  输入网址是<a href="http://www.google.com，显示的是www.baidu.com" target="_blank" rel="noopener">www.google.com，显示的是www.baidu.com</a>  </p>
<p>HTTP劫持的现象：<br>输入网址是<a href="http://www.google.com，显示的也是谷歌首页，但是页面某个地方出现了广告。" target="_blank" rel="noopener">www.google.com，显示的也是谷歌首页，但是页面某个地方出现了广告。</a></p>
<h1 id="DNS劫持和HTTP劫持的原理"><a href="#DNS劫持和HTTP劫持的原理" class="headerlink" title="DNS劫持和HTTP劫持的原理"></a>DNS劫持和HTTP劫持的原理</h1><ul>
<li><p>DNS劫持原理：DNS服务器修改域名对应的解析地址，把这个域名解析到另一个IP地址上。</p>
</li>
<li><p>HTTP劫持原理：HTTP劫持，运营商或中间人修改http响应的内容(比如修改HTML代码，加入js代码)，使得页面出现广告等情况。</p>
<blockquote>
<p>具体来说：HTTP请求到达运营商路由器后被标记，响应到达运营商路由器的时候，修改返回的响应内容，插入广告等，直接返回修改后的响应，它会先到达客户端。真正的响应到达客户端后就会被丢弃。</p>
</blockquote>
</li>
</ul>
<h1 id="如何解决DNS劫持和HTTP劫持"><a href="#如何解决DNS劫持和HTTP劫持" class="headerlink" title="如何解决DNS劫持和HTTP劫持"></a>如何解决DNS劫持和HTTP劫持</h1><ul>
<li><p>解决DNS劫持： 换一下可靠的DNS服务器。</p>
</li>
<li><p>解决HTTP劫持：全站用HTTPS。<br>因为客户端和服务器来往的数据是加密过的，运营商或中间人无法直接修改服务器返回的响应(比如无法修改HTML代码，插入js代码)。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/浅谈单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/浅谈单例模式/" itemprop="url">
                  浅谈单例模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-03 11:53:17 / 修改时间：11:54:05" itemprop="dateCreated datePublished" datetime="2018-11-03T11:53:17+08:00">2018-11-03</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-什么是单例模式"><a href="#1-什么是单例模式" class="headerlink" title="1.什么是单例模式"></a>1.什么是单例模式</h1><blockquote>
<p>保证一个类只有一个实例，并提供一个访问该实例的静态方法</p>
</blockquote>
<h1 id="2-为什么要用单例模式"><a href="#2-为什么要用单例模式" class="headerlink" title="2.为什么要用单例模式"></a>2.为什么要用单例模式</h1><blockquote>
<p>在内存中只有一个实例，减少内存浪费，避免对象反复创建、销毁带来的性能上的影响。</p>
</blockquote>
<h1 id="3-单例模式的实现方式"><a href="#3-单例模式的实现方式" class="headerlink" title="3.单例模式的实现方式"></a>3.单例模式的实现方式</h1><p>常见的五种方式：饿汉式、懒汉式、双重检查锁、静态内部类、枚举  </p>
<p>主要从三个地方考察它们的优劣：延迟加载、线程安全、性能</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>特点：类加载的时候就创建这个唯一静态实例对象，静态获取方法直接返回。  </p>
<p>延迟加载：否  </p>
<p>线程安全：因为是静态实例，所以是在类加载的[初始化]阶段就完成了实例创建，由JVM保证天然线程安全。  </p>
<p>性能：好  </p>
<p>缺点：如果唯一实例的创建需要参数，饿汉式就没法设置唯一实例的参数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//饿汉式</span><br><span class="line">public class Singleton1 &#123;</span><br><span class="line">    private static Singleton1 instance = new Singleton1();</span><br><span class="line">    private Singleton1() &#123;&#125;</span><br><span class="line">    public static Singleton1 getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>特点：要用的时候才创建对象  </p>
<p>延迟加载：是  </p>
<p>线程安全：是(静态获取方法加synchronized关键字修饰)  </p>
<p>性能：不太好(因为synchronized关键字)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//懒汉式</span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private static Singleton2 instance;</span><br><span class="line">    private Singleton2() &#123;&#125;</span><br><span class="line">    public static synchronized Singleton2 getInstance() &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">            instance = new Singleton2();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>特点：懒汉式的基础上，缩小同步粒度，两个if判断，volatie关键字  </p>
<p>延迟加载：是  </p>
<p>线程安全：是  </p>
<p>性能：不太好(因为synchronized关键字)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//双重检查锁  双重检查 是说两个if检查</span><br><span class="line">//静态唯一实例要用volatile修饰，同步锁粒度减小</span><br><span class="line">public class Singleton3 &#123;</span><br><span class="line">    private static volatile Singleton3 instance;</span><br><span class="line"> </span><br><span class="line">    private Singleton3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton3.class) &#123;</span><br><span class="line">                if (instance == null)</span><br><span class="line">                   instance = new Singleton3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查锁，JDK1.5之后要用volatile关键字解决JVM指令重排带来的多线程安全问题。  </p>
<p>如果唯一静态实例不用volatile关键字修饰，则JVM会有指令重排的操作  </p>
<p>例如:  </p>
<p>instance = new Singleton();  </p>
<p>这不是一个原子操作，实际上是执行了三个步骤  </p>
<p>①给对象分配内存空间  </p>
<p>②调用构造函数初始化对象的成员  </p>
<p>③引用指向对象  </p>
<p>由于JVM的指令重排，上面三个步骤的执行顺序是不确定的。  </p>
<p>有可能是①③②的顺序执行，在多线程下就可能出现问题。  </p>
<p>假设线程A执行到instance = new Singleton3()，JVM执行了①③步骤，即给对象分配内存空间，然后引用指向对象(此时对象还没有初始化)，此时线程A挂起，线程B执行。  </p>
<p>线程B进入同步代码块的if语句就发现，此时instance引用不为空了。<br>那线程B就拿这个对象引用，去进行操作，访问对象的成员时，就会抛出空指针异常。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>特点：把创建唯一静态实例的过程，放到了静态内部类中  </p>
<p>延迟加载：是<br>(静态内部类不会随着类加载立刻加载，用到的时候才加载)  </p>
<p>线程安全：是(唯一静态实例的创建是在类加载的[初始化]阶段完成的，由JVM保证天然线程安全)  </p>
<p>性能：好 （没有使用synchronized关键字）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//静态内部类</span><br><span class="line">//把创建静态唯一实例的过程，放在一个静态内部类里面，</span><br><span class="line">//因为静态内部类用到的时候才会加载到内存，实现了延迟加载</span><br><span class="line">public class Singleton4 &#123;</span><br><span class="line">    private static class SingletonInstanceClass&#123;</span><br><span class="line">        private static Singleton4 instance = new Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    private Singleton4() &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    public static Singleton4 getInstance() &#123;</span><br><span class="line">        return SingletonInstanceClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><p>特点：简单，枚举上写一个INSTANCE即可，而且不会被反射和反序列化破坏单例模式的原则  </p>
<p>延迟加载：否  </p>
<p>线程安全：好(枚举定义的对象，默认在static代码块中创建，由于JVM的特性保证线程安全)  </p>
<p>性能：好  </p>
<p>枚举默认的构造函数是私有的，访问枚举实例时会调用构造函数，每个枚举实例都是static final修饰的，只能被实例化一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用枚举实现单例模式，可以避免反射和反序列化破坏单例模式</span><br><span class="line">public enum Singleton5 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-应该如何选用单例模式的实现方式"><a href="#4-应该如何选用单例模式的实现方式" class="headerlink" title="4.应该如何选用单例模式的实现方式"></a>4.应该如何选用单例模式的实现方式</h1><ul>
<li>单例对象占用资源大，要求延迟加载，那就使用静态内部类</li>
<li>单例对象占用资源少、不需要延迟加载，且涉及到反序列创建对象，那就用枚举</li>
</ul>
<h1 id="5-单例模式常见使用场景"><a href="#5-单例模式常见使用场景" class="headerlink" title="5.单例模式常见使用场景"></a>5.单例模式常见使用场景</h1><ul>
<li>Windows操作系统中的任务管理器</li>
<li>数据库连接池</li>
<li>Spring容器管理的Bean</li>
<li>Servlet编程中的每个Servlet</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/19/Lambda表达式的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/Lambda表达式的使用/" itemprop="url">
                  lambda表达式的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-19 21:49:13 / 修改时间：21:50:27" itemprop="dateCreated datePublished" datetime="2018-09-19T21:49:13+08:00">2018-09-19</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Lambda表达式的作用"><a href="#Lambda表达式的作用" class="headerlink" title="Lambda表达式的作用"></a>Lambda表达式的作用</h2><p>Java8中提出的lambda表达式可以使得我们的代码编写更加简洁。<br><strong>Lambda表达式本身可以看作是一个接口的实现。</strong></p>
<ul>
<li>使用场景：<br>  在Java代码编写过程中，有时候需要我们把一整块代码赋值给一个变量，用Lambda表达式使得代码更简洁。</li>
</ul>
<h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><ul>
<li>(parameters) -&gt; expression</li>
<li>(parameters) -&gt; {statements;}</li>
</ul>
<h2 id="常见Lambda表达式的例子"><a href="#常见Lambda表达式的例子" class="headerlink" title="常见Lambda表达式的例子"></a>常见Lambda表达式的例子</h2><p>1.在new一个匿名内部类(接口)，需要重写其方法的时候。例如往Collection.sort()中传入一个Comparator比较器对象，常见写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Person o1, Person o2) &#123;</span><br><span class="line">        return o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用Lambda表达式之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, (o1,o2)-&gt;(o2.age - o1.age));</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><img src="https://pic4.zhimg.com/80/v2-a712753b42972e094a548ae02fa82987_hd.jpg" alt="image"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/19/Trie字典树的介绍与Java实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/Trie字典树的介绍与Java实现/" itemprop="url">
                  Trie字典树的介绍与Java实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-19 12:35:29 / 修改时间：12:38:40" itemprop="dateCreated datePublished" datetime="2018-09-19T12:35:29+08:00">2018-09-19</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Trie字典树概述"><a href="#Trie字典树概述" class="headerlink" title="Trie字典树概述"></a>Trie字典树概述</h2><blockquote>
<p>Trie树，也叫做<em>单词查找树、字典树、前缀树</em>，是一种树形结构，典型应用是统计和排序大量的字符串，经常被搜索引擎用来进行文本词频统计。</p>
</blockquote>
<h2 id="Trie字典树的优势和局限性"><a href="#Trie字典树的优势和局限性" class="headerlink" title="Trie字典树的优势和局限性"></a>Trie字典树的优势和局限性</h2><p><strong>优势</strong></p>
<ol>
<li>Trie的设计是基于利用空间换时间的思想，利用字符串的公共前缀来减少字符串的比较次数，以此达到较高的查询效率。</li>
<li>Trie插入和查询的时间复杂度和要处理的字符串长度w有关，为O(w)。<br>上述时间复杂度和Trie字典树中的节点总数没有关系。</li>
</ol>
<p><strong>局限性</strong></p>
<ol>
<li>Trie字典树需要消耗较多空间</li>
</ol>
<h2 id="Trie的Java实现"><a href="#Trie的Java实现" class="headerlink" title="Trie的Java实现"></a>Trie的Java实现</h2><ul>
<li>Trie定义</li>
<li>Trie添加字符串</li>
<li>Trie查询字符串</li>
<li>Trie查询前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line"></span><br><span class="line">    //字典树的节点类定义</span><br><span class="line">    //每个节点包含两个属性，一个属性表示这个节点是否是某个字符串的结尾(boolean值表示)</span><br><span class="line">    //一个属性表示该节点下面的若干个节点是什么（Map映射来表示）</span><br><span class="line">    //字典树Trie其实也就是个多叉树</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        public boolean isWord;</span><br><span class="line">        public TreeMap&lt;Character, Node&gt; next;</span><br><span class="line">        public Node(boolean isWord) &#123;</span><br><span class="line">            this.isWord = isWord;</span><br><span class="line">            next = new TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            this(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根节点Node标识一个字典树</span><br><span class="line">    private Node root;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    //初始化字典树时创建一个根节点</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: 往字典树中插入一个字符串</span><br><span class="line">     *  实际上就是在字典树中生成(或遍历)字符串中对应字符的多个节点，并在节点末尾设置单词结束标志</span><br><span class="line">    * @Param:</span><br><span class="line">    * @return:</span><br><span class="line">    * @Author: dzc</span><br><span class="line">    * @Date: 2018/9/19</span><br><span class="line">    */</span><br><span class="line">    public void add(String word) &#123;</span><br><span class="line">        //cur是节点指针，一直在移动</span><br><span class="line">        Node cur = root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char c = word.charAt(i);</span><br><span class="line">            if (cur.next.get(c) == null)</span><br><span class="line">                cur.next.put(c, new Node());</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        //当cur指向字符串最后一个字符对应的节点时，判断这个节点是不是已经被设置为单词结尾了</span><br><span class="line">        //换句话来说，可能会出现往字典树中添加重复单词的情况，</span><br><span class="line">        //只有当添加新单词时，才把这个单词维护到字典树中，否则上述操作只是Node指针遍历了一下而已</span><br><span class="line">        if (!cur.isWord) &#123;</span><br><span class="line">            cur.isWord = true;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: 判断字典树中是否存在一个字符串（单词）</span><br><span class="line">     * 本质就是遍历这个字符串中字符对应的节点，如果遍历一遍都没问题</span><br><span class="line">     * 则说明字典树中存在这个字符串</span><br><span class="line">     * 唯一需要注意的就是，当遍历到最后一个字符对应的节点时，确保它的单词结尾标识为true</span><br><span class="line">     * 否则这个字符串只是一个单词前缀，不能认为是一个存在于字典树中的单词</span><br><span class="line">    * @Param:</span><br><span class="line">    * @return:</span><br><span class="line">    * @Author: dzc</span><br><span class="line">    * @Date: 2018/9/19</span><br><span class="line">    */</span><br><span class="line">    public boolean contains(String word) &#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        //每次遍历，Node指针是在节点间不断向下移动的</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char c = word.charAt(i);</span><br><span class="line">            if (cur.next.get(c) == null)</span><br><span class="line">                return false;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        //当找到这个传入函数的这个字符串最后一个字符对应的节点时，判断它是否是单词结尾</span><br><span class="line">        //是单词结尾才说明单词在字典树中存在，否则这个单词只是恰好是其他单词的前缀而已</span><br><span class="line">        return cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * @Description: 查询字典树中是否有单词以prefix为前缀</span><br><span class="line">     * 其实和上面contains方法类似，只要prefix这个字符串中字符对应的节点都能遍历一遍</span><br><span class="line">     * 那么则认为这个字典树中有单词以prefix为前缀</span><br><span class="line">    * @Param:</span><br><span class="line">    * @return:</span><br><span class="line">    * @Author: dzc</span><br><span class="line">    * @Date: 2018/9/19</span><br><span class="line">    */</span><br><span class="line">    public boolean isPrefix(String prefix) &#123;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        for (int i = 0; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            char c = prefix.charAt(i);</span><br><span class="line">            if (cur.next.get(c) == null)</span><br><span class="line">                return false;</span><br><span class="line">            cur = cur.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/映射的链表和二分搜索树实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/映射的链表和二分搜索树实现/" itemprop="url">
                  映射的链表和二分搜索树实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-16 22:55:06 / 修改时间：22:55:42" itemprop="dateCreated datePublished" datetime="2018-09-16T22:55:06+08:00">2018-09-16</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="映射Map的接口设计"><a href="#映射Map的接口设计" class="headerlink" title="映射Map的接口设计"></a>映射Map的接口设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void add(K key, V value);</span><br><span class="line">    V remove(K key);</span><br><span class="line">    boolean contains(K key);</span><br><span class="line">    V get(K key);</span><br><span class="line">    void set(K key, V newValue);</span><br><span class="line">    int getSize();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射的链表实现"><a href="#映射的链表实现" class="headerlink" title="映射的链表实现"></a>映射的链表实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //链表内部的Node节点类需要进行改造，才能存放Key-Value键值对数据</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        public K key;</span><br><span class="line">        public V value;</span><br><span class="line">        public Node next;</span><br><span class="line"></span><br><span class="line">        public Node(K key, V value, Node next) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Node(K key, V value) &#123;</span><br><span class="line">            this(key, value, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            this(null, null, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override public String toString() &#123;</span><br><span class="line">            return key.toString() + &quot; : &quot; + value.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //虚拟头结点</span><br><span class="line">    private Node dummyHead;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public LinkedListMap() &#123;</span><br><span class="line">        dummyHead = new Node();</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 映射中，不存在重复key</span><br><span class="line">     * 如果传入的键值对，key已经存在的话，就认为是对当前key对应的键值对的修改操作</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void add(K key, V value) &#123;</span><br><span class="line">       Node node = getNode(key);</span><br><span class="line">       if (node == null) &#123; //key不存在的情况</span><br><span class="line">           //此时映射中没有该键值对，可插入新键值对(相对于链表，则是在头部插入新节点)</span><br><span class="line">           //由于底层是链表实现，所以在链表头部完成新节点的添加</span><br><span class="line">           dummyHead.next = new Node(key, value, dummyHead.next);</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       else //key已经存在的话，就认为是对当前key对应的键值对的修改操作</span><br><span class="line">           node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除映射中的键值对</span><br><span class="line">     * 由于底层是由链表实现的，所以实际上就是链表删除结点的操作</span><br><span class="line">     * 由于删除元素的位置可能在头部、尾部、任意位置</span><br><span class="line">     * 所以使用虚拟头结点dummyHead来统一对链表结点的删除操作</span><br><span class="line">     *  删除操作的核心：找到要删除结点的前一个结点，修改其指针指向</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V remove(K key) &#123;</span><br><span class="line">        Node prev = dummyHead;</span><br><span class="line">        while (prev.next != null) &#123;</span><br><span class="line">            if (prev.next.key.equals(key))</span><br><span class="line">                break;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //找到待删除结点的前一个结点</span><br><span class="line">        //上述while循环后，prev指针可能已经指向链表最后一个结点了</span><br><span class="line">        //所以要进行非空判断，否则后面的代码会出现空指针异常</span><br><span class="line">        if (prev.next != null) &#123;</span><br><span class="line">            Node delNode = prev.next;</span><br><span class="line">            prev.next = delNode.next;</span><br><span class="line">            delNode.next = null;</span><br><span class="line">            size--;</span><br><span class="line">            return delNode.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //找不到要删除的键值对，则返回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据key找得到节点，则认为集合中包含该元素</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(K key) &#123;</span><br><span class="line">        return getNode(key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据key值，找出value值</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        Node node = getNode(key);</span><br><span class="line">        return node == null ? null:node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(K key, V newValue) &#123;</span><br><span class="line">        Node node = getNode(key);</span><br><span class="line">        if (node == null)</span><br><span class="line">            throw new IllegalArgumentException(key + &quot;doesn&apos;t exist!&quot;);</span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据键值对的key值，找到链表中对应的节点</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node getNode(K key) &#123;</span><br><span class="line">        //获取链表中第一个真正的节点</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        while (cur.next != null) &#123;</span><br><span class="line">            if (cur.key.equals(key))</span><br><span class="line">                return cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果遍历了整个链表都找到key值对应的节点Node,return null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射的二分搜索树实现"><a href="#映射的二分搜索树实现" class="headerlink" title="映射的二分搜索树实现"></a>映射的二分搜索树实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class BSTMap&lt;K extends Comparable, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">//底层基于二分搜索树实现的映射，二分搜索树中的元素，要求继承Comparable接口</span><br><span class="line">    //来保证二分搜索树的有序性</span><br><span class="line"></span><br><span class="line">    //原有的BST的内部Node需要进行改造，才能存放键值对</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        public K key;</span><br><span class="line">        public V value;</span><br><span class="line">        public Node left, right;</span><br><span class="line"></span><br><span class="line">        public Node(K key, V value) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BST中维护一个根节点，这个BST已经被重新定义了</span><br><span class="line">    private Node root;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public BSTMap() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(K key, V value) &#123;</span><br><span class="line">        root = add(root, key ,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 往映射中添加键值对，本质是往BST中添加元素，需要考虑新元素的排放位置</span><br><span class="line">     * 对BST的添加元素的操作本质还是依靠递归来完成，返回新二叉树的根节点</span><br><span class="line">     * @param node</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node add(Node node, K key, V value) &#123;</span><br><span class="line"></span><br><span class="line">        //递归终止条件</span><br><span class="line">        if (node == null) &#123;//找到一个叶子节点的位置</span><br><span class="line">            //该键值对之前并不存在，创建一个Node来保存键值对的信息</span><br><span class="line">            size ++;</span><br><span class="line">            return new Node(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //递归逻辑</span><br><span class="line">        if (key.compareTo(node.key) &lt; 0)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        else if (key.compareTo(node.key) &gt; 0)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        else //key.compareTo(node.key) == 0，</span><br><span class="line">            node.value = value;//该键值对之前已经存在，找到key对应的Node, 重新设置它的value</span><br><span class="line"></span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V remove(K key) &#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            return node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对映射中key对应的键值对的删除操作，本质上是BST中删除结点的操作</span><br><span class="line">     * 被删除的结点可能有左子树，右子树，或两者都有，或只是叶子结点</span><br><span class="line">     * 除了叶子结点外，其他结点的删除操作，会影响到BST整体的组织结构，需要进行相应处理</span><br><span class="line">     * @param node</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node remove(Node node, K key) &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        if (key.compareTo(node.key) &lt; 0) &#123;</span><br><span class="line">            node.left = remove(node.left, key);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (key.compareTo(node.key) &gt; 0) &#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123; //key.compareTo(node.key) == 0，意味着找到了key对应的结点</span><br><span class="line">            //待删除结点的左子树为空的情况，把待删除节点的右子树挂接到上一层根节点上</span><br><span class="line">            if (node.left == null) &#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = null;</span><br><span class="line">                size--;</span><br><span class="line">                return rightNode; //这个return ,返回给谁了？</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //待删除结点的右子树为空的情况，把待删除结点的左子树挂接到上一层根节点上</span><br><span class="line">            if (node.right == null) &#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = null;</span><br><span class="line">                size--;</span><br><span class="line">                return leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //待删除结点的左右子树都不为空的情况，找出其右子树中最小的结点，来代替待删除结点</span><br><span class="line">            //这个右子树中最小的结点，需要被删除</span><br><span class="line">            Node successor = minumun(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = null;</span><br><span class="line">            return successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找到二叉树左边的，没有左子树的结点</span><br><span class="line">     * 这个就是值最小的结点</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node minumun(Node node) &#123;</span><br><span class="line">        if (node.left == null)</span><br><span class="line">            return node;</span><br><span class="line">        return minumun(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回新二分搜索树的根</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node removeMin(Node node) &#123;</span><br><span class="line"></span><br><span class="line">        //左子树为空，把右子树挂接到上一层根节点的左结点上</span><br><span class="line">        if (node.left == null) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = null;</span><br><span class="line">            size--;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        //递归逻辑</span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(K key) &#123;</span><br><span class="line">        return getNode(root, key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        return node == null ? null:node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在BST中找到key对应的结点，然后设置该结点的value值</span><br><span class="line">     * @param key</span><br><span class="line">     * @param newValue</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void set(K key, V newValue) &#123;</span><br><span class="line">       Node node = getNode(root, key);</span><br><span class="line">       if (node == null)</span><br><span class="line">           throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);</span><br><span class="line"></span><br><span class="line">       node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入key和根节点，就能查找出BST中key对应的结点</span><br><span class="line">     * 对BST中元素的查找，本质依然是递归</span><br><span class="line">     * @param node</span><br><span class="line">     * @param key</span><br><span class="line">     * @return 找不到key对应的结点，返回null</span><br><span class="line">     */</span><br><span class="line">    private Node getNode(Node node, K key) &#123;</span><br><span class="line">        //递归终止条件</span><br><span class="line">        if (node == null)</span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        //递归逻辑</span><br><span class="line">        if (key.equals(node.key))</span><br><span class="line">            return node;</span><br><span class="line">        else if(key.compareTo(node.key) &lt; 0)</span><br><span class="line">           return getNode(node.left, key);</span><br><span class="line">        else //key.compareTo(node.key) &gt; 0</span><br><span class="line">            return getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Pride and Prejudice&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();</span><br><span class="line">        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) &#123;</span><br><span class="line">            System.out.println(&quot;Total words: &quot; + words.size());</span><br><span class="line"></span><br><span class="line">            BSTMap&lt;String, Integer&gt; map = new BSTMap&lt;&gt;();</span><br><span class="line">            for (String word : words) &#123;</span><br><span class="line">                if (map.contains(word))</span><br><span class="line">                    map.set(word, map.get(word) + 1);</span><br><span class="line">                else</span><br><span class="line">                    map.add(word, 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Total different words: &quot; + map.getSize());</span><br><span class="line">            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));</span><br><span class="line">            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/集合的链表和二分搜索树实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/集合的链表和二分搜索树实现/" itemprop="url">
                  集合的链表和二分搜索树实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-16 22:48:55 / 修改时间：22:49:34" itemprop="dateCreated datePublished" datetime="2018-09-16T22:48:55+08:00">2018-09-16</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="集合的链表实现"><a href="#集合的链表实现" class="headerlink" title="集合的链表实现"></a>集合的链表实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    //基于链表实现的集合，内部维护一个LinkedList对象</span><br><span class="line">    //对集合的操作，实际上就是对LinkedList链表对象的操作</span><br><span class="line">    private LinkedList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    public LinkedListSet() &#123;</span><br><span class="line">        list =new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 集合元素的唯一性，添加时要检查元素是否重复</span><br><span class="line">     * @param e</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        if(!list.contains(e))</span><br><span class="line">            list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(E e) &#123;</span><br><span class="line">        return list.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(E e) &#123;</span><br><span class="line">        list.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Pride and Prejudice&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words1 = new ArrayList&lt;&gt;();</span><br><span class="line">        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words1)) &#123;</span><br><span class="line">            System.out.println(&quot;Total words: &quot; + words1.size());</span><br><span class="line"></span><br><span class="line">            BSTSet&lt;String&gt; set1 = new BSTSet&lt;&gt;();</span><br><span class="line">            for (String word : words1)</span><br><span class="line">                set1.add(word);</span><br><span class="line">            System.out.println(&quot;Total different words: &quot; + set1.getSize());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;A Tale of Two Cities&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; words2 = new ArrayList&lt;&gt;();</span><br><span class="line">        if(FileOperation.readFile(&quot;a-tale-of-two-cities.txt&quot;, words2))&#123;</span><br><span class="line">            System.out.println(&quot;Total words: &quot; + words2.size());</span><br><span class="line"></span><br><span class="line">            BSTSet&lt;String&gt; set2 = new BSTSet&lt;&gt;();</span><br><span class="line">            for(String word: words2)</span><br><span class="line">                set2.add(word);</span><br><span class="line">            System.out.println(&quot;Total different words: &quot; + set2.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合的二分搜索树实现"><a href="#集合的二分搜索树实现" class="headerlink" title="集合的二分搜索树实现"></a>集合的二分搜索树实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class BSTSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private BST&lt;E&gt; bst;</span><br><span class="line"></span><br><span class="line">    public BSTSet() &#123;</span><br><span class="line">        bst = new BST&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        bst.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(E e) &#123;</span><br><span class="line">        return bst.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(E e) &#123;</span><br><span class="line">        bst.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return bst.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return bst.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/15/二分搜索树的Java实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="薛定谔的狗">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/15/二分搜索树的Java实现/" itemprop="url">
                  二分搜索树的Java实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-15 18:42:11 / 修改时间：18:44:19" itemprop="dateCreated datePublished" datetime="2018-09-15T18:42:11+08:00">2018-09-15</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h2><ol>
<li>BST二分搜索树和Node节点的定义</li>
<li>BST中添加元素的方法</li>
<li>判断二分搜索树中是否含有某个元素</li>
<li>深度遍历优先之前中后序遍历</li>
<li>前序遍历的非递归实现</li>
<li>深度优先遍历</li>
<li>查找最小，最大元素</li>
<li>删除最小，最大元素</li>
<li>删除BST中任意一个元素</li>
</ol>
<h3 id="1-BST二分搜索树和Node节点的定义"><a href="#1-BST二分搜索树和Node节点的定义" class="headerlink" title="1. BST二分搜索树和Node节点的定义"></a>1. BST二分搜索树和Node节点的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class BST&lt;E extends Comparable&lt;E&gt;&gt;  &#123;</span><br><span class="line"></span><br><span class="line">    //二分搜索树中定义一个Node类，表示树中的节点</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        public E e;</span><br><span class="line">        public Node left, right;</span><br><span class="line"></span><br><span class="line">        public Node(E e) &#123;</span><br><span class="line">            this.e = e;</span><br><span class="line">            left = null;</span><br><span class="line">            right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //二分搜索树的属性，有根节点和所有节点的个数</span><br><span class="line">    private Node root;</span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    //BST的初始化</span><br><span class="line">    public BST() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-BST中添加元素的方法"><a href="#2-BST中添加元素的方法" class="headerlink" title="2. BST中添加元素的方法"></a>2. BST中添加元素的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//私有一个内部调用的add方法，这个add方法是递归的，不对用户暴露</span><br><span class="line">//传入根节点和新元素，完成对BST的添加元素的过程</span><br><span class="line">private void add(Node node, E e)&#123;</span><br><span class="line"></span><br><span class="line">    //递归终止条件</span><br><span class="line">    if (e.equals(node.e))</span><br><span class="line">        return;</span><br><span class="line">    else if (e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123;</span><br><span class="line">        node.left = new Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123;</span><br><span class="line">        node.right = new Node(e);</span><br><span class="line">        size++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //递归的逻辑</span><br><span class="line">    if (e.compareTo(node.e) &lt; 0)</span><br><span class="line">        add(node.left, e);</span><br><span class="line">    else //e.compareTo(node.e) &gt; 0</span><br><span class="line">        add(node.right, e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对添加元素方法的改进"><a href="#对添加元素方法的改进" class="headerlink" title="对添加元素方法的改进"></a>对添加元素方法的改进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * </span><br><span class="line">  * 当某个节点是NULL时，就添加新元素，并返回给上一层根节点的左节点或右节点</span><br><span class="line">  * 这样添加的新元素，也就和原二分搜索树挂接起来了</span><br><span class="line">  * 最终返回的是新二分搜索树的根节点root</span><br><span class="line"> */</span><br><span class="line"> private Node add(Node node, E e) &#123;</span><br><span class="line">     //递归终止条件</span><br><span class="line">     if (node == null) &#123;</span><br><span class="line">         size++;</span><br><span class="line">         return new Node(e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //递归逻辑</span><br><span class="line">     if (e.compareTo(node.e) &lt; 0)</span><br><span class="line">         node.left = add(node.left, e);</span><br><span class="line">     else if (e.compareTo(node.e) &gt; 0)</span><br><span class="line">         node.right = add(node.right, e);</span><br><span class="line"></span><br><span class="line">     return node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-判断二分搜索树中是否含有某个元素"><a href="#3-判断二分搜索树中是否含有某个元素" class="headerlink" title="3. 判断二分搜索树中是否含有某个元素"></a>3. 判断二分搜索树中是否含有某个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 判断二分搜索树中是否包含元素e,实际上仍然是使用递归算法</span><br><span class="line">  * 二分搜索树有天然的递归性，在左节点和右节点中递归寻找</span><br><span class="line">  * @param node</span><br><span class="line">  * @param e</span><br><span class="line">  * @return</span><br><span class="line">  */</span><br><span class="line"> private boolean contains(Node node, E e) &#123;</span><br><span class="line"></span><br><span class="line">     //递归终止条件</span><br><span class="line">     if (node == null)</span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     //递归逻辑</span><br><span class="line">     if (e.compareTo(node.e) == 0)</span><br><span class="line">         return true;</span><br><span class="line">     else if (e.compareTo(node.e) &lt; 0)</span><br><span class="line">         return contains(node.left, e);</span><br><span class="line">     else //e.compareTo(node.e) &gt; 0</span><br><span class="line">         return contains(node.right, e);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-深度遍历优先之前中后序遍历"><a href="#4-深度遍历优先之前中后序遍历" class="headerlink" title="4. 深度遍历优先之前中后序遍历"></a>4. 深度遍历优先之前中后序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder() &#123;</span><br><span class="line">       preOrder(root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 深度优先遍历之前序遍历，访问元素顺序：根左右</span><br><span class="line">    * 依然是采用递归实现</span><br><span class="line">    * @param node</span><br><span class="line">    */</span><br><span class="line">   private void preOrder(Node node) &#123;</span><br><span class="line">       //递归终止条件</span><br><span class="line">       if (node == null)</span><br><span class="line">           return;</span><br><span class="line"></span><br><span class="line">       //递归逻辑</span><br><span class="line">       System.out.println(node.e);</span><br><span class="line">       preOrder(node.left);</span><br><span class="line">       preOrder(node.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public void inOrder() &#123;</span><br><span class="line">       inOrder(root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 深度优先遍历之中序遍历，访问元素顺序：左根右</span><br><span class="line">    * 递归实现</span><br><span class="line">    * @param node</span><br><span class="line">    */</span><br><span class="line">   private void inOrder(Node node) &#123;</span><br><span class="line">       //递归终止条件</span><br><span class="line">       if (node == null)</span><br><span class="line">           return;</span><br><span class="line"></span><br><span class="line">       //递归逻辑</span><br><span class="line">       inOrder(node.left);</span><br><span class="line">       System.out.println(node.e);</span><br><span class="line">       inOrder(node.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void postOrder() &#123;</span><br><span class="line">       postOrder(root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 深度优先遍历之后序遍历，访问元素顺序：左右根</span><br><span class="line">    * 递归实现</span><br><span class="line">    * @param node</span><br><span class="line">    */</span><br><span class="line">   private void postOrder(Node node) &#123;</span><br><span class="line">       //递归终止条件</span><br><span class="line">       if (node == null)</span><br><span class="line">           return;</span><br><span class="line"></span><br><span class="line">       //递归逻辑</span><br><span class="line">       postOrder(node.left);</span><br><span class="line">       postOrder(node.right);</span><br><span class="line">       System.out.println(node.e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-前序遍历的非递归实现"><a href="#5-前序遍历的非递归实现" class="headerlink" title="5. 前序遍历的非递归实现"></a>5. 前序遍历的非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前序遍历的非递归实现</span><br><span class="line"> * 底层基于java.util.Stack的栈来实现</span><br><span class="line"> * 根节点压栈，然后出栈，出栈的同时，右节点-&gt;左节点再压栈，然后左节点-&gt;右节点出栈</span><br><span class="line"> */</span><br><span class="line">public void preOrderNR() &#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line">        if (cur.right != null)</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        if (cur.left != null)</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-深度优先遍历"><a href="#6-深度优先遍历" class="headerlink" title="6. 深度优先遍历"></a>6. 深度优先遍历</h3><pre><code>/**
 * 深度优先遍历之层序遍历
 * 底层基于Queue队列来实现
 * 根节点入队，然后出队，出队的同时，左节点-&gt;右节点再入队
 */
public void leverOrder() {

    if (root == null)
        return;

    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();
    q.add(root);

    while (!q.isEmpty()) {
        Node cur = q.remove();
        System.out.println(cur.e);

        if (cur.left != null)
            q.add(cur.left);
        if (cur.right != null)
            q.add(cur.right);
    }

}
</code></pre><h3 id="7-查找最小，最大元素"><a href="#7-查找最小，最大元素" class="headerlink" title="7. 查找最小，最大元素"></a>7. 查找最小，最大元素</h3><pre><code>/**
 * 查找二分搜索树中，值最小的元素
 * @return
 */
public E minimun() {
    if (size == 0)
        throw new IllegalArgumentException(&quot;BST is empty&quot;);

    Node minNode = minimun(root);
    return minNode.e;
}

/**
 * 查找最小值的操作是递归实现的
 * 根据二分搜索树的顺序性，最左边的某个没有左节点的元素，即为最小元素
 * @param node
 * @return
 */
private Node minimun(Node node) {

    //一直找到最左边的没有左节点的元素，并返回该元素
    if (node.left == null)
        return node;
    return minimun(node.left);
}




public E maximun() {
    if (size == 0)
        throw new IllegalArgumentException(&quot;BST is empty&quot;);
    return maximun(root).e;
}

/**
 * 查找最大值的操作是递归实现的
 * 根据二分搜索树的顺序性，最右边的某个没有右节点的元素，即为最大元素
 * @param node
 * @return
 */
private Node maximun(Node node) {
    if (node.right == null)
        return node;
    return  maximun(node.right);
}
</code></pre><h3 id="8-删除最小，最大元素"><a href="#8-删除最小，最大元素" class="headerlink" title="8. 删除最小，最大元素"></a>8. 删除最小，最大元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public E removeMin() &#123;</span><br><span class="line">        E ret = minimun();</span><br><span class="line">        root = removeMin(root);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除以node为根的二分搜索树中的最小节点</span><br><span class="line">     * 返回新二分搜索树的根节点</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node removeMin(Node node) &#123;</span><br><span class="line"></span><br><span class="line">        //递归终止条件</span><br><span class="line">        //当一个节点的左节点为空时，意味着这个节点就是最小值的节点</span><br><span class="line">        //这个结点如果是叶子节点，就返回null给上层根节点的左节点</span><br><span class="line">        //不是的话，就返回右子树给上层根节点的左节点</span><br><span class="line">        if (node.left == null) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = null;</span><br><span class="line">            size--;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        //递归逻辑</span><br><span class="line">        //返回来的结点可能是最小值元素的右子树或null</span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E removeMax() &#123;</span><br><span class="line">        E ret = maximun();</span><br><span class="line">        root = removeMax(root);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除以node为根的二分搜索树中的最大节点</span><br><span class="line">     * 返回新二分搜索树的根节点</span><br><span class="line">     * @param node</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node removeMax(Node node) &#123;</span><br><span class="line">        //当一个节点的右节点为空时，则意味着这个节点就是最大节点</span><br><span class="line">        if (node.right == null) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = null;</span><br><span class="line">            size--;</span><br><span class="line">            return  leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //返回来的结点可能是最大值元素的左子树或null</span><br><span class="line">        node.right = removeMax(node.right);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-删除BST中任意一个元素"><a href="#9-删除BST中任意一个元素" class="headerlink" title="9. 删除BST中任意一个元素"></a>9. 删除BST中任意一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 删除二分搜索树中的任意元素</span><br><span class="line">    * 返回新二分搜索树的根节点</span><br><span class="line">    * @param node</span><br><span class="line">    * @param e</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private Node remove(Node node, E e) &#123;</span><br><span class="line">       if (node == null)</span><br><span class="line">           return null;</span><br><span class="line">       if (e.compareTo(node.e) &lt; 0) &#123;</span><br><span class="line">           node.left = remove(node.left , e);</span><br><span class="line">           return node;</span><br><span class="line">       &#125;</span><br><span class="line">       else if (e.compareTo(node.e) &gt; 0) &#123;</span><br><span class="line">           node.right = remove(node.right, e);</span><br><span class="line">           return node;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123; //e.compareTo(node.e) == 0 找到传入的这个元素了</span><br><span class="line">           //待删除元素的左子树为空的情况</span><br><span class="line">           if (node.left == null) &#123;</span><br><span class="line">               Node rightNode = node.right;</span><br><span class="line">               node.right = null;</span><br><span class="line">               size--;</span><br><span class="line">               return rightNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //待删除元素的右子树为空的情况</span><br><span class="line">           if (node.right == null) &#123;</span><br><span class="line">               Node leftNode = node.left;</span><br><span class="line">               node.left = null;</span><br><span class="line">               size--;</span><br><span class="line">               return leftNode;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           //待删除元素的左右子树都不为空的情况,就需要找出新的根节点来代替待删除元素了</span><br><span class="line">           //这个新的根节点，根据二分搜索树的顺序性，就要求比左子树的所有元素值要大，右子树的所有元素值要小</span><br><span class="line">           //那我们就找出右子树的最小元素作为新的根节点，这就满足了上述条件</span><br><span class="line">           Node successor = minimun(node.right);</span><br><span class="line">           //successor是新的根节点，连接待删除元素的左右子树</span><br><span class="line">           successor.right = removeMin(node.right);//返回的是删除掉最小元素后的右子树的根节点</span><br><span class="line">           successor.left = node.left;</span><br><span class="line"></span><br><span class="line">           //断开待删除元素和其左右子树的关系</span><br><span class="line">           node.left = node.right = null;</span><br><span class="line"></span><br><span class="line">           //返回新二叉树的根节点</span><br><span class="line">           return successor;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">薛定谔的狗</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">薛定谔的狗</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
